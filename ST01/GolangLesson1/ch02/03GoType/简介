Go 语言类型
    Go 语言的类型大体可分为基本数据类型、复合数据类型和接口类型这三种，
    我们日常Go编码中使用最多的就是基本数据类型，而基本数据类型中使用占比最大的又是数值类型。

    Go 语言原生支持的数值类型包括整型、浮点型以及复数类型
        整型：分为平台无关型和平台相关型。
        平台无关整型，它们在任何 CPU 架构或任何操作系统下面，长度都是固定不变的。
            平台无关的整型也可以分成两类：有符号整型（int8~int64）和无符号整型（uint8~uint64）
        Go 语言原生提供了三个平台相关整型，它们是 int、uint 与 uintptr，在不同 CPU 架构或操作系统下面，它们的长度是不一致的。
        
        浮点型：float32和float64，默认使用float64，精度更高。 

        复数类型：complex64 和 complex128，complex64 的实部与虚部都是 float32 类型
            而 complex128 的实部与虚部都是 float64 类型。如果一个复数没有显示赋予类型，那么它的默认类型为 complex128
            可以通过复数字面值直接初始化一个复数类型变量
                var c = 5 + 6i
                var d = 0o123 + .12345E+5i // 83+12345i
            
            Go 提供了 complex 函数，方便我们创建一个 complex128 类型值
                var c = complex(5, 6) // 5 + 6i
                var d = complex(0o123, .12345E+5) // 83+12345i

            可以通过 Go 提供的预定义的函数 real 和 imag，来获取一个复数的实部与虚部，返回值为一个浮点类型
                var c = complex(5, 6) // 5 + 6i
                r := real(c) // 5.000000
                i := imag(c) // 6.000000

        字符串类型:字符串类型为 string,string 类型其实是一个“描述符”，它本身并不真正存储字符串数据，而仅是由一个指向底层存储的指针和字符串的长度字段组成的
            Go 原生支持 string好处：
                string 类型的数据是不可变的，提高了字符串的并发安全性和存储利用率
                    var s string = "hello"
                    s[0] = 'k' // 错误：字符串的内容是不可改变的
                    s = "gopher" // ok

                没有结尾’\0’，而且获取长度的时间复杂度是常数时间，消除了获取字符串长度的开销

                原生支持“所见即所得”的原始字符串，大大降低构造多行字符串时的心智负担

                对非 ASCII 字符提供原生支持，消除了源码在不同环境下显示乱码的可能
        rune类型：本质上就是一个整型数，我们可用整型值来直接作为字符字面值给 rune 变量赋值

复合类型：Go语言原生内置了多种复合数据类型，包括数组、切片（slice）、map、结构体，以及像channel这类用于并发程序设计的高级复合数据类型
    最基础的复合类型，数组。
    数组概念：Go语言的数组是一个长度固定的、由同构类型元素组成的连续序列
        数组两个重要属性：元素的类型和数组长度（元素的个数）
        数组类型变量的声明：var arr [N]T
        如果两个数组类型的元素类型 T 与数组长度 N 都是一样的，那么这两个数组类型是等价的，如果有一个属性不同，它们就是两个不同的数组类型。
    切片：可以看做一个变长数组
        声明并初始化一个切片变量
        var nums = []int{1, 2, 3, 4, 5, 6}
    切片的动态扩容：
    “动态扩容”指的就是，当我们通过 append 操作向切片追加数据的时候，如果这时切片的 len 值和 cap 值是相等的，也就是说切片底层数组
    已经没有空闲空间再来存储追加的值了，Go 运行时就会对这个切片做扩容操作，来保证切片始终能存储下追加的新值。